<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><title>What 48,000 AI Agent Trajectories Reveal</title><style>:root{--bg:#fafaf9;--text:#1a1a1a;--muted:#6b6b6b;--accent:#c45d3e;--border:#e5e5e3;--blockquote-bg:#f8f7f4;--table-header:#f0efeb}*{margin:0;padding:0;box-sizing:border-box}body{font-family:'Georgia','Times New Roman',serif;background:var(--bg);color:var(--text);line-height:1.75;font-size:18px;-webkit-font-smoothing:antialiased}.container{max-width:720px;margin:0 auto;padding:60px 24px 100px}h1{font-size:2.2em;font-weight:700;line-height:1.2;margin-bottom:0.6em;letter-spacing:-0.02em}h2{font-size:1.5em;font-weight:700;margin-top:2.5em;margin-bottom:0.6em}h3{font-size:1.2em;font-weight:600;margin-top:2em;margin-bottom:0.5em}p{margin-bottom:1.2em}a{color:var(--accent);text-decoration:underline}strong{font-weight:700}em{font-style:italic}hr{border:none;border-top:1px solid var(--border);margin:3em 0}blockquote{border-left:3px solid var(--accent);background:var(--blockquote-bg);padding:1em 1.5em;margin:1.5em 0;border-radius:0 6px 6px 0}blockquote p{margin-bottom:0.5em;font-size:0.95em;color:#333}blockquote p:last-child{margin-bottom:0}.table-wrapper{overflow-x:auto;margin:1.5em 0}table{width:100%;border-collapse:collapse;font-size:0.92em;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif}th{background:var(--table-header);text-align:left;padding:10px 14px;font-weight:600;border-bottom:2px solid var(--border)}td{padding:10px 14px;border-bottom:1px solid var(--border)}tr:last-child td{border-bottom:none}figure{margin:2em 0;text-align:center}figure img{max-width:100%;border-radius:8px;box-shadow:0 2px 12px rgba(0,0,0,0.08)}.container img{max-width:100%;height:auto;border-radius:8px;box-shadow:0 2px 12px rgba(0,0,0,0.08);margin:1em 0}ol,ul{margin:1em 0 1.5em 1.5em}li{margin-bottom:0.6em;line-height:1.6}code.inline{font-family:'SF Mono','Fira Code','Consolas',monospace;font-size:0.88em;background:#fdf0e8;color:#9a3412;padding:2px 7px;border-radius:4px;border:1px solid #f5d0b5;font-weight:600}pre.illustration-note{background:#f9f6f0;border:1px dashed #d4c9b8;border-radius:8px;padding:1.2em 1.5em;margin:1.5em 0;font-size:0.85em;line-height:1.6;font-family:'Georgia',serif;font-style:italic;color:var(--muted);white-space:pre-wrap}pre.illustration-note code{font-family:inherit;font-style:inherit;background:none;color:inherit;border:none}@media(max-width:600px){body{font-size:16px}.container{padding:30px 16px 60px}h1{font-size:1.7em}}</style></head><body><div class="container">
<h1>What 48,000 AI Agent Trajectories Reveal About the Signals We Should Be Watching</h1>
<p>I downloaded every publicly available trajectory from the SWE-bench Verified leaderboard -- 48,580 runs across 134 different AI agent systems -- and pulled out 40+ behavioral features from each one. I was looking for a handful of signals that tell us whether an agent run is headed for success or failure, regardless of framework, model, or problem.</p>
<p>That is not what came out of the data.</p>
<p><em>Some terminology: a <strong>run</strong> is one attempt by an agent to solve a task. A <strong>trajectory</strong> (or <strong>trace</strong>) is the full log of that run -- every step, every file read, every edit, and the agent's reasoning along the way. I use these interchangeably below.</em></p>
<p>The signals people track -- error rates, strategy patterns, step counts -- shift meaning depending on the framework, the model, and the problem. The one signal that held up most consistently is something none of the standard observability tools (LangSmith, LangFuse, Braintrust, AgentOps) measure. It is vocabulary richness: whether the agent keeps introducing new concepts or talks itself in circles.</p>
<hr />
<h2>What I Expected to Find</h2>
<p>I assumed there should be a "heart rate monitor" for AI agents -- some signal, maybe error rate or planning quality, that tells you if a run is on track or going off the rails. The standard observability stack lands on <strong>latency, token counts, cost per request, error rates, step counts.</strong> They are easy to measure, but the data suggests they are the weak signals. The features most predictive of success and failure live in a layer none of those tools reach.</p>
<hr />
<h2>What does a stuck run look like?</h2>
<p>Here is what the trace files look like up close. These are real trajectories from SWE-Agent running Claude 3.5 Sonnet -- one of the earlier submissions, picked because its verbose reasoning traces give the clearest window into what the agent is actually doing. (The quantitative patterns hold across current SOTA models -- Opus 4.5, GPT-5, DeepSeek-V3 -- as I will show below.) Both use the same framework and model, but produce different outcomes.</p>
<p><strong>A successful run</strong> (django__django-14672, resolved in 18 steps):</p>
<blockquote>
<p><strong>Step 1:</strong> "Let's start by locating the file where the ManyToManyRel class is defined..."
<strong>Step 5:</strong> "I see now. The ManyToManyRel class is imported from the reverse_related module..."
<strong>Step 12:</strong> "Great, we can see that make_hashable is already imported on line 14..."
<strong>Step 15:</strong> "It looks like we're in the Django source code repository, not a Django project. In this case, we should use Django's runtests.py..."</p>
</blockquote>
<p>Every step introduces something new -- a new file, a new class, a new hypothesis. The agent's vocabulary <em>grows</em>, consistent with it progressively learning the codebase.</p>
<p><strong>A stuck run</strong> (django__django-15128, failed after 56 steps):</p>
<blockquote>
<p><strong>Step 47:</strong> "The changes look good. The script has been simplified and should now focus on reproducing the core issue..."
<strong>Step 49:</strong> "The changes look good. The script now includes a proper app configuration and the models are associated with the 'reproduce'..."
<strong>Step 51:</strong> "The changes look good. The script now includes a proper app configuration and registers the app dynamically..."
<strong>Step 53:</strong> "The changes look good. The script has been simplified and should now focus on reproducing the core issue..."</p>
</blockquote>
<p><code class="inline">"The changes look good."</code> Four times. While looping on the same error. The last 15 actions are: edit, run, error, edit, run, error -- with nearly identical code each time. Only 127 unique words across 2,195 total. The agent has been stuck for 30+ steps and <em>shows no sign of recognizing it.</em></p>
<p>Look at the hedging language in that stuck trajectory. The agent reads like it senses something is off. But it cannot break the loop. It just keeps saying <code class="inline">"the changes look good"</code> like repeating it might make it true.</p>
<p><em>Here is what success and failure look like side by side. Same agent, same harness, different tasks.</em></p>
<p><img alt="Figure 1: Trajectory anatomy" src="figures/fig1_trajectory_anatomy.png" /></p>
<p><strong>Figure 1.</strong> A resolved trajectory (left, django-14672, 18 steps) and a failed trajectory (right, django-15128, 56 steps) from SWE-Agent + Claude 3.5 Sonnet. The resolved run mixes search and navigation with a few targeted edits. The failed run is almost entirely edits with 54 errors, the agent locked in the loop described above.</p>
<h3>Do agents repeat themselves before failing?</h3>
<p>To formalize this, I measured <strong>vocabulary richness</strong> -- the ratio of unique words to total words in the agent's reasoning. Is the agent covering new ground, or talking itself in circles?</p>
<p>Here is what that looked like across 2,904 trajectories (the SWE-Agent subset of the full 48,580 -- these produce the richest reasoning traces):</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>Vocabulary Richness</th>
<th>Success Rate</th>
<th>Count</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bottom quartile (&lt; 0.18)</td>
<td>10.7%</td>
<td>726</td>
</tr>
<tr>
<td>Second quartile (0.18 - 0.27)</td>
<td>24.2%</td>
<td>726</td>
</tr>
<tr>
<td>Third quartile (0.27 - 0.37)</td>
<td>33.1%</td>
<td>726</td>
</tr>
<tr>
<td>Top quartile (&gt; 0.37)</td>
<td>60.2%</td>
<td>726</td>
</tr>
</tbody>
</table></div>
<p><strong>Agents in the top quartile succeed 5.6 times as often as those in the bottom.</strong> I expected error count to be the strongest signal, but it was nowhere close to vocabulary richness.</p>
<p>Important caveat: shorter texts mechanically produce higher vocabulary richness (a well-known property in linguistics). Successful runs tend to be shorter, so part of the effect is a length artifact. After controlling for trajectory length, the effect drops from Cohen's d = 0.89 to 0.59 -- still the strongest signal in the entire analysis, but weaker than the headline number suggests. I report both because the distinction matters.</p>
<p>These core results come from SWE-Agent's earlier submissions (GPT-4, Claude 3.5, GPT-4o), but the signal is not limited to older models. I validated vocabulary richness across seven model-harness configurations spanning current SOTA:</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>Model + Harness</th>
<th>Vocab Richness (Cohen's d)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Opus 4.5 (OpenHands)</td>
<td>+0.75</td>
</tr>
<tr>
<td>DeepSeek-V3</td>
<td>+0.71</td>
</tr>
<tr>
<td>Claude 3.5 (SWE-Agent)</td>
<td>+0.69</td>
</tr>
<tr>
<td>KimiK2 (OpenHands)</td>
<td>+0.67</td>
</tr>
<tr>
<td>Sonnet 4.5 / Sonar</td>
<td>+0.64</td>
</tr>
<tr>
<td>Claude 4 Sonnet (OpenHands)</td>
<td>+0.52</td>
</tr>
<tr>
<td>GPT-5 (OpenHands)</td>
<td>+0.22</td>
</tr>
</tbody>
</table></div>
<p>The direction is consistent across all configurations, but the magnitude varies 3x -- from a large effect with Opus 4.5 to a small effect with GPT-5. That variation is itself informative, and I will return to it. But vocabulary richness predicts success across today's leading models, not just the older ones where I first found it.</p>
<p>The standard trace format -- OpenTelemetry's GenAI semantic conventions -- captures <code class="inline">gen_ai.usage.output_tokens</code> (how many tokens) but not whether those tokens contain new concepts or recycled phrases. Token count measures verbosity; vocabulary richness measures whether the agent is actually <em>learning</em> the codebase. The difference in predictive power is substantial.</p>
<h3>What Vocabulary Richness Is Actually Measuring</h3>
<p>When an agent keeps producing new file names, new function references, new hypotheses, the model's token distribution is being continually reshaped by new input from genuine exploration. Each step feeds new context into the attention mechanism, which shifts what gets generated next. When vocabulary collapses -- <code class="inline">"the changes look good"</code> on repeat -- the model appears to have converged on a region of its output space where every probable next step leads back to the same sequence. Forcing diverse vocabulary from the outside would not address this -- the vocabulary reflects the model's internal state, and if that state has stopped changing, the output will not either.</p>
<h3>Error Direction, Not Error Count</h3>
<p>Another finding that changed how I think about monitoring: <strong>the total number of errors barely predicts failure</strong> (Cohen's d = -0.14, basically noise). But whether errors are <em>increasing or decreasing</em> over the trajectory is far more diagnostic (d = 0.43 after length controls, pooled across all SWE-Agent configurations -- note that per-configuration values vary, as Figure 7 shows).</p>
<p><img alt="Figure 3: Error trend" src="figures/fig3_error_trend.png" /></p>
<p><strong>Figure 3.</strong> Resolved and failed runs show similar error rates through mid-trajectory but diverge in the final third, where resolved runs decline sharply while failed runs stay elevated.</p>
<p>Raw error count on its own is a very weak health signal. What matters is whether errors are converging toward zero or piling up over the course of the run. Tracking that requires computing error density per phase of the trajectory, not just the aggregate. It is similar to debugging -- if you are making progress, errors go down even if you started with a lot. If you are stuck, you keep hitting new issues without resolving old ones.</p>
<p>Three more patterns survived my controls: <strong>file revisit rate</strong> (failed agents cycle through the same files without making changes between visits), <strong>hedging language</strong> ("maybe," "let me try," "not sure" appear more often per step in failed runs), and <strong>edit-edit chaining</strong> (consecutive edits without running tests -- guessing rather than reasoning). All of these require semantic analysis of the agent's output that current tooling does not attempt.</p>
<p>Separately, LangChain's team, working on Terminal Bench 2.0, independently found <em>the same patterns.</em> They describe agents that "wrote a solution, re-read its own code, confirmed it looks ok, and stopped" -- the same <code class="inline">"the changes look good"</code> loop, discovered from the other direction. They call the failure mode "doom loops":</p>
<blockquote>
<p>Agents become "myopic once they've decided on a plan," making "small variations to the same broken approach 10+ times."</p>
</blockquote>
<p>Their fix was not a better prompt or a smarter model. It was a <code class="inline">LoopDetectionMiddleware</code> -- a harness-level intervention that interrupts the agent from outside. The agent could not save itself; something else had to intervene. The propensity to doom-loop was not solely a property of the model -- it was also shaped by what the harness did (or did not do) to interrupt it.</p>
<p>That raises an important question: if the harness determines the behavioral patterns, what exactly is a monitoring tool observing -- the agent, or the scaffolding around it?</p>
<h3>Do these signals generalize?</h3>
<p>I tested whether these behavioral signals hold up across different framework-model combinations, and for most of them, they do not.</p>
<p><img alt="Figure 7: Cross-model signals" src="figures/fig7_cross_model_signals.png" /></p>
<p><strong>Figure 7.</strong> Each cell shows whether a behavioral signal predicts success (green) or not (white/red). The top row (vocabulary richness) is consistently green. Everything else is a patchwork.</p>
<p>As the validation table showed, vocabulary richness stays positive across all seven configurations. But the other signals -- error trend, file revisit rate, hedging language -- are inconsistent or near-zero in OpenHands configurations.</p>
<p>Why? SWE-Agent produces rich, free-form reasoning at every step -- the model is "thinking aloud." OpenHands uses more structured tool calls with less free-form reasoning. The behavioral signals are not absent in OpenHands; they are <em>buried beneath the framework's structure.</em></p>
<p><strong>This is a three-way dependency.</strong> The signals depend on the framework, on the model running inside that framework, and on the problems it was evaluated on. It is not "SWE-Agent vs. OpenHands." It is "SWE-Agent + Claude 3.5 + coding tasks" vs. "OpenHands + GPT-5 + coding tasks." Change any of those three and the patterns can shift.</p>
<p>LangChain's own results validate this directly. They tuned their harness for GPT-5.2-Codex and got a 13.7-point improvement. Running the same harness with Claude Opus 4.6 scored 59.6% -- different model, same harness, different outcome. The three-way dependency is not abstract. It is what practitioners encounter when they try to transfer improvements across stacks.</p>
<p>This means universal monitoring dashboards are aimed at a problem that may not have universal signals.</p>
<hr />
<h2>Does searching before editing help?</h2>
<p>This one almost made it into the headline before it fell apart. I am including it because what happened when it broke is more interesting than the original result.</p>
<p>Working with the earlier SWE-Agent submissions (GPT-4, Claude 3.5, GPT-4o -- the models with the richest trajectory data), I found what looked like a clean, actionable result: agents that search the codebase before their first edit had significantly higher resolve rates.</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>Strategy</th>
<th>GPT-4</th>
<th>Claude 3.5</th>
<th>GPT-4o</th>
</tr>
</thead>
<tbody>
<tr>
<td>Search-first</td>
<td>25%</td>
<td>40%</td>
<td>31%</td>
</tr>
<tr>
<td>Edit-first</td>
<td>12%</td>
<td>28%</td>
<td>18%</td>
</tr>
</tbody>
</table></div>
<p>"Make your agents search before they edit." I was ready to make it a headline -- until I ran the causal checks.</p>
<p><strong>Task difficulty explains most of the gap.</strong> Within the same difficulty tier, the advantage shrank to 1-2 points. Easier tasks were more likely to be approached search-first -- probably not because searching <em>made</em> them easier, but because the kind of tasks where searching is the obvious move tend to also be the kind that are easier in general.</p>
<p><strong>Model capability dominates strategy.</strong> Claude 3.5 editing first (28%) outperforms GPT-4 searching first (25%). If strategy mattered more than capability, this should be reversed.</p>
<p><strong>Within the same model and difficulty tier, the differences were noise</strong> -- 1-3 points in either direction, too small to be a signal.</p>
<p>The correlation was real -- "search-first agents succeed 12-13 points more often" is true in the raw data. But good agents search first because they are <em>capable enough to know that searching is the right opening move.</em> They are not good because they search first. Mixing up what good agents do with what makes agents good -- I suspect there is a lot of this in the agent evaluation literature.</p>
<p>For monitoring tools, the warning is direct. If a dashboard flags "this agent searched before editing -- good sign!" it is giving you confidence based on a correlation that collapses under causal scrutiny. <strong>Is this pattern a cause or a consequence of capability?</strong> Unless you have tested it causally, you do not know.</p>
<p>How many other "best practices" in agent design are correlational artifacts waiting to collapse?</p>
<hr />
<h2>Why No Single Agent Wins</h2>
<p>If you look at the SWE-bench leaderboard, the instinct is to just use the winner and ignore everything else. The data says that instinct leaves serious performance on the table.</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>Configuration</th>
<th>Tasks Solved</th>
</tr>
</thead>
<tbody>
<tr>
<td>Best single framework (Sonar)</td>
<td>396 / 500 (79.2%)</td>
</tr>
<tr>
<td>Oracle -- best of all 134</td>
<td>468 / 500 (93.6%)</td>
</tr>
<tr>
<td>Gap</td>
<td>+72 tasks</td>
</tr>
</tbody>
</table></div>
<p>To check whether that 72-task gap is real or just noise, I bootstrapped 10,000 random five-framework ensembles and compared two types: "diverse" ensembles (frameworks drawn from different families -- different prompt styles, different scaffolding, different memory handling) versus "homogeneous" ensembles (frameworks from the same family). Diverse ensembles consistently solved more tasks, with a medium-to-large effect size (d=0.63, p=10^-50 on the bootstrap distribution).</p>
<p><img alt="Figure 4: Framework complementarity" src="figures/fig4_framework_complementarity.png" /></p>
<p><strong>Figure 4.</strong> Each bar adds the framework contributing the most new solves. The gap between the first bar and the ceiling is 72 tasks that the best single approach misses.</p>
<p>Different architectures have different blind spots. A run that looks unusual compared to the top-ranked framework might be the only one that solved a given task.</p>
<hr />
<h2>Which tasks remain unsolved?</h2>
<p>Beyond the behavioral signals, the data reveals something about the tasks themselves.</p>
<p><img alt="Figure 5: Task difficulty" src="figures/fig5_task_difficulty.png" /></p>
<p><strong>Figure 5.</strong> 32 tasks (red, left) remain unsolved by all 134 submissions. 163 tasks (green, right) are solved by 100+ submissions. The distribution is bimodal -- easy core and hard frontier.</p>
<p>32 tasks that nobody has solved. 134 approaches, thousands of runs, zero successes. Nearly every agent in the dataset follows roughly the same loop: explore the codebase, form a hypothesis, edit, test, iterate. If these 32 tasks require something categorically different -- deep architectural reasoning that does not decompose into explore-edit-test steps -- then scaling the current paradigm will not solve them. That is a different kind of ceiling than "we need a bigger model."</p>
<hr />
<h2>Open Questions</h2>
<p>LangChain got a 13.7-point improvement by changing the harness, not the model. If the harness shapes the behavioral patterns, what are monitoring tools actually observing -- the agent, or the harness?</p>
<p>The stuck agent repeated <code class="inline">"the changes look good"</code> four times while its hedging language went up. It seems to sense the problem but cannot override the loop. If agents can detect their own stuckness but lack the mechanism to act on it, that is a different engineering problem than if they are blind to it.</p>
<p>The search-first strategy collapsed under causal controls. Claims like "chain-of-thought improves reasoning" and "agents should plan before acting" rest on similar correlational evidence. How many would survive the same checks?</p>
<p>Vocabulary richness is the closest thing to a universal signal in this data, and even it varies 3x across configurations. Maybe the three-way dependency (framework + model + problem) is fundamental, and a single monitoring dashboard that works across all agent stacks is not feasible.</p>
<hr />
<h2>Limitations</h2>
<p>The analysis is limited to SWE-Agent trajectories for the behavioral signals, and the signals weaken or disappear in OpenHands-style frameworks. Length-matching reduces but does not eliminate confounds -- a within-task design would be stronger. Error detection relies on keyword matching, which is imperfect in both directions. Vocabulary richness <em>predicts</em> success; we have not proven that forcing diverse vocabulary would <em>improve</em> performance -- the features likely reflect underlying reasoning quality rather than causing it. All tasks are Python repositories; other languages may produce different patterns. The oracle ensemble is an upper bound, not a deployment plan. And my survey of observability tools reflects publicly available documentation as of early 2026; these platforms evolve fast.</p>
<hr />
<h2>What I Am Left With</h2>
<p>I wanted to know if you can predict, from an agent's trajectory, whether it will succeed. After examining 48,580 runs across 134 systems and 40+ behavioral features, the answer is that it depends on the framework, the model, and the task. No single signal generalizes cleanly.</p>
<p>Vocabulary richness came closest — positive across all seven model-harness configurations I tested. But even it varies 3x in strength. The other signals (error trend, hedging, file revisits) are framework-dependent. The practical next step is probably framework-aware monitoring. But if reading a signal requires knowing the harness, the model, and the problem domain first, I am not sure that counts as observability.</p>
<p>An agent, 30 steps into a loop, producing <code class="inline">"the changes look good"</code> for the fourth time. Something in its output suggests it senses the problem. Nothing in its architecture lets it stop.</p>
<hr />
<p><em>This analysis covers the SWE-bench Verified leaderboard as of early 2026: 134 submissions, 500 tasks, approximately 48,580 trajectory files (~43,100 parseable). All statistical tests are two-sided. Effect sizes are exploratory and should be treated as hypothesis-generating. Code and extracted features are available upon request.</em></p>
<hr />
<h2>References and Data Sources</h2>
<ul>
<li>SWE-bench Verified — Jimenez, C. E., Yang, J., Wettig, A., Yao, S., Pei, K., Press, O., &amp; Narasimhan, K. (2024). <a href="https://arxiv.org/abs/2310.06770">SWE-bench: Can Language Models Resolve Real-World GitHub Issues?</a> <em>ICLR 2024</em>.</li>
<li><a href="https://www.swebench.com/">SWE-bench Verified Leaderboard</a> — source of all 134 submissions and 500 tasks analyzed in this article.</li>
<li><a href="https://github.com/princeton-nlp/SWE-agent">SWE-Agent</a> — Yang, J., Jimenez, C. E., Wettig, A., Lieret, K., Yao, S., Narasimhan, K., &amp; Press, O. (2024). SWE-agent: Agent-Computer Interfaces Enable Automated Software Engineering. <em>NeurIPS 2024</em>.</li>
<li><a href="https://github.com/All-Hands-AI/OpenHands">OpenHands</a> (formerly OpenDevin) — Wang, X., et al. (2024). OpenDevin: An Open Platform for AI Software Developers as Generalist Agents.</li>
<li><a href="https://github.com/OpenAutoCoder/Agentless">Agentless</a> — Xia, C. S., Deng, Y., Dunn, S., &amp; Zhang, L. (2024). Agentless: Demystifying LLM-based Software Engineering Agents.</li>
<li><a href="https://www.swebench.com/">Sonar</a> — top-performing framework on the leaderboard (79.2% solve rate).</li>
<li>Factory-Code-Droid, JoyCode, Warp, Devlo — referenced from leaderboard submissions.</li>
<li>LangChain Terminal Bench 2.0 — Referenced for independent discovery of "doom loop" patterns and LoopDetectionMiddleware. <a href="https://blog.langchain.dev/">LangChain blog</a>.</li>
<li><a href="https://smith.langchain.com/">LangSmith</a> — LangChain's trace and evaluation platform.</li>
<li><a href="https://langfuse.com/">LangFuse</a> — open-source LLM observability.</li>
<li><a href="https://www.braintrust.dev/">Braintrust</a> — AI evaluation and monitoring.</li>
<li><a href="https://www.agentops.ai/">AgentOps</a> — agent monitoring and analytics.</li>
<li><a href="https://opentelemetry.io/docs/specs/semconv/gen-ai/">OpenTelemetry GenAI Semantic Conventions</a> — referenced for <code class="inline">gen_ai.usage.output_tokens</code> standard.</li>
</ul>
<hr />
<p><strong>How to cite this article:</strong></p>
<pre><code class="inline">@article{thakur2026agenttraj,
  title   = {What 48,000 AI Agent Trajectories Reveal About the Signals We Should Be Watching},
  author  = {Thakur, Shailja},
  year    = {2026},
  month   = {February},
  note    = {Blog post. Analysis of SWE-bench Verified leaderboard trajectories.},
  url     = {https://shailja-thakur.github.io/blog/agent-trajectories/}
}
</code></pre>
</div></body></html>